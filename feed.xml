<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://tuebel.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://tuebel.github.io/blog/" rel="alternate" type="text/html" /><updated>2022-10-21T01:48:51-05:00</updated><id>https://tuebel.github.io/blog/feed.xml</id><title type="html">ü§ñ Tim √úbelh√∂r‚Äôs blog</title><subtitle>Hacks, tricks and awesomeness for robots and you. GoROS!</subtitle><entry><title type="html">[WIP] Demistify ROS Hardware &amp;amp; Control</title><link href="https://tuebel.github.io/blog/ros/hardware/ros_control/2020/06/27/demystify-ros-hw.html" rel="alternate" type="text/html" title="[WIP] Demistify ROS Hardware &amp;amp; Control" /><published>2020-06-27T00:00:00-05:00</published><updated>2020-06-27T00:00:00-05:00</updated><id>https://tuebel.github.io/blog/ros/hardware/ros_control/2020/06/27/demystify-ros-hw</id><content type="html" xml:base="https://tuebel.github.io/blog/ros/hardware/ros_control/2020/06/27/demystify-ros-hw.html"><![CDATA[<h1 id="motivation">Motivation</h1>
<p>Information about implementing your own <code class="highlighter-rouge">HardwareInterface</code> or <code class="highlighter-rouge">RobotHW</code> is sparse and spread all over the internet.</p>

<h1 id="hardwareinterface">HardwareInterface</h1>
<ul>
  <li>Implemntation</li>
  <li>Configuration</li>
</ul>

<h1 id="ros-control">ROS Control</h1>
<ul>
  <li>Implementation</li>
  <li>Configuration</li>
</ul>

<h1 id="ros_control_boilerplate">ros_control_boilerplate</h1>
<p>This is probably the easiest and go-to place for implementing a new <code class="highlighter-rouge">HardwareInterface</code> from scratch.
As the name suggests, most of the boilerplate you will always have to write is taken away from you.</p>

<h1 id="multiple-robots">Multiple Robots</h1>
<h2 id="separate-control-loops-namespacing">Separate Control Loops: Namespacing</h2>
<h2 id="single-control-loop-combined-hardware">Single Control Loop: Combined Hardware</h2>]]></content><author><name></name></author><category term="ROS" /><category term="Hardware" /><category term="ros_control" /><summary type="html"><![CDATA[Accumulation of information and best practices for implementing your own ROS HardwareInterface for ros_control.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://tuebel.github.io/blog/images/plain_cmake_preview.png" /><media:content medium="image" url="https://tuebel.github.io/blog/images/plain_cmake_preview.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">ROS Plain CMake</title><link href="https://tuebel.github.io/blog/ros/cmake/2020/06/27/ros-plain-cmake.html" rel="alternate" type="text/html" title="ROS Plain CMake" /><published>2020-06-27T00:00:00-05:00</published><updated>2020-06-27T00:00:00-05:00</updated><id>https://tuebel.github.io/blog/ros/cmake/2020/06/27/ros-plain-cmake</id><content type="html" xml:base="https://tuebel.github.io/blog/ros/cmake/2020/06/27/ros-plain-cmake.html"><![CDATA[<h1 id="motivation">Motivation</h1>
<p>Even though it is considered best practice to separate the ROS code from the logic, they are commonly placed in the same ROS package.
To enable reusing the code in a ROS-agnostic context, the logic and the ROS-bits should be placed in a different packages.
However, this requires the programmer to manually add the packaging magic of <code class="highlighter-rouge">catkin_package()</code>.
This blog post provides insight on what is required to make a CMake project ‚Äòfind_packagable‚Äô <sup id="fnref:CmakePackage" role="doc-noteref"><a href="#fn:CmakePackage" class="footnote" rel="footnote">1</a></sup>.</p>

<h1 id="example-repository">Example repository</h1>
<p>A minimal working example of a ROS workspace can be found <a href="https://github.com/Tuebel/ros_plain_cmake">here</a>.
This workspace contains three packages:</p>
<ol>
  <li><a href="https://github.com/Tuebel/ros_plain_cmake/tree/master/src/plain_cmake">plain_cmake</a>: Minimal example of a plain CMake package for ROS.</li>
  <li><a href="https://github.com/Tuebel/ros_plain_cmake/tree/master/src/catkin_pkg">catkin_pkg</a>: Test the plain_cmake package in a ROS workspace.</li>
  <li><a href="https://github.com/Tuebel/ros_plain_cmake/tree/master/src/consumer_cmake">consumer_cmake</a>: Test the system installation of plain_cmake in another CMake project.</li>
</ol>

<p>This blog post will fokus on the plain_cmake package but will also give short examples of reusing the package.</p>

<h1 id="packagexml">package.xml</h1>
<p>Even though a <em>package.xml</em> is not required for the CMake functionalities, it is still required in the context of ROS.
This file gets parsed by the build tool, for example <code class="highlighter-rouge">catkin build</code> to determine the dependencies and the build order <sup id="fnref:REP140" role="doc-noteref"><a href="#fn:REP140" class="footnote" rel="footnote">2</a></sup>.
To mark our project as plain CMake we add the following tags to our <em>package.xml</em>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;buildtool_depend&gt;</span>cmake<span class="nt">&lt;/buildtool_depend&gt;</span>
<span class="nt">&lt;exports&gt;</span>
  <span class="nt">&lt;build_type&gt;</span>cmake<span class="nt">&lt;/build_type&gt;</span>
<span class="nt">&lt;/exports&gt;</span>
</code></pre></div></div>

<p>Many dependencies can be installed via <a href="http://wiki.ros.org/rosdep">rosdep</a> so they should be added to the <em>package.xml</em>, too.
Make sure to visit <a href="http://rosindex.github.io/">rosindex</a> to find the correct name of the dependencies.
For example for linear algebra, matrix and vector operations the package could depend on <a href="http://eigen.tuxfamily.org/">Eigen</a>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;depend&gt;</span>eigen<span class="nt">&lt;/depend&gt;</span>
</code></pre></div></div>

<h1 id="cmakeliststxt">CMakeLists.txt</h1>
<h2 id="includes-and-settings">Includes and Settings</h2>
<p>First, we include some CMake helpers.
<code class="highlighter-rouge">GNUInstallDirs</code> provides variables for default installation directories like <code class="highlighter-rouge">${CMAKE_INSTALL_LIBDIR}</code> while the <code class="highlighter-rouge">CMakePackageConfigHelpers</code> provides functions for the automatic generation of the CMake configuration files.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">include</span><span class="p">(</span>GNUInstallDirs<span class="p">)</span>
<span class="nb">include</span><span class="p">(</span>CMakePackageConfigHelpers<span class="p">)</span>
</code></pre></div></div>

<p>Afterwards, some package specific variables are set.
We will use some modern features which require CMake version 3.1 or higher.
Then, we define a name and version for the package and set the C++ standard to version 11.
In the last line, we define the variable <code class="highlighter-rouge">ConfigPackageLocation</code> which contains the path where our CMake package configuration files will be installed <sup id="fnref:UseCmakeEnabled" role="doc-noteref"><a href="#fn:UseCmakeEnabled" class="footnote" rel="footnote">3</a></sup>.
Under Linux, CMake will search in several locations for the Config.cmake file.
One of the locations is <code class="highlighter-rouge">lib/&lt;package name&gt;/cmake</code>.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.1<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>plain_cmake<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>PLAIN_CMAKE_VERSION 0.1<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 11<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>ConfigPackageLocation <span class="si">${</span><span class="nv">CMAKE_INSTALL_LIBDIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>/cmake<span class="p">)</span>
</code></pre></div></div>

<p>Finally, we need to include the dependencies of our package.
In this example, the Eigen3 library is required.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">find_package</span> <span class="p">(</span>Eigen3 3.3 REQUIRED NO_MODULE<span class="p">)</span>
</code></pre></div></div>

<h2 id="defining-targets">Defining targets</h2>
<p>This step is very similar to defining targets in a catkin package.
In this example, we define a library named after project which consists of a single source file.
It is good practice to include headers and sources for each target instead of using the global <code class="highlighter-rouge">include_directories()</code> <sup id="fnref:DoCmakeRight" role="doc-noteref"><a href="#fn:DoCmakeRight" class="footnote" rel="footnote">4</a></sup>.
For the sources, <code class="highlighter-rouge">target_sources()</code> is considered IDE friendly but defining a library without any source will lead to a catkin warning.
Adding at least one source file to the library seems to do the trick and all sources can be added via <code class="highlighter-rouge">target_sources()</code> 
Including the header directories however is a bit more complicated, as the <a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html">CMake documentation</a> states: ‚ÄúInclude directories usage requirements commonly differ between the build-tree and the install-tree.‚Äù.
Therefore, we have to use generator expressions to specify the correct include paths <sup id="fnref:HeaderOnly" role="doc-noteref"><a href="#fn:HeaderOnly" class="footnote" rel="footnote">5</a></sup>.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_library</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib src/matrix_operations.cpp<span class="p">)</span>
<span class="nf">target_sources</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib PRIVATE
  src/matrix_operations.cpp<span class="p">)</span>
<span class="nb">target_include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib PUBLIC
  $&lt;BUILD_INTERFACE:<span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span>/include&gt;
  $&lt;INSTALL_INTERFACE:include&gt;<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib PUBLIC Eigen3::Eigen<span class="p">)</span>
</code></pre></div></div>

<p>Moreover, we define an application and link it to our library:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_executable</span><span class="p">(</span>example_app src/example_app.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>example_app <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib<span class="p">)</span>
</code></pre></div></div>

<h2 id="installing-the-targets">Installing the targets</h2>
<p>The obvious reason for using <code class="highlighter-rouge">install(TARGETS)</code> is to copy the libraries, binaries and headers to a system directory, where they can be found by other projects <sup id="fnref:ModernCmakeInstall" role="doc-noteref"><a href="#fn:ModernCmakeInstall" class="footnote" rel="footnote">6</a></sup>.
The not so obvious reason is that we can use the <code class="highlighter-rouge">EXPORT</code> command to associate the installation targets with <code class="highlighter-rouge">plain_cmakeTargets</code>, which we will use in the next section.
The <code class="highlighter-rouge">ARCHIVE</code>, <code class="highlighter-rouge">LIBRARY</code> and <code class="highlighter-rouge">RUNTIME</code> <code class="highlighter-rouge">DESTINATION</code> commands define where the files will be installed.
Here, we use the <code class="highlighter-rouge">GNUInstallDirs</code> helper variables for the destination.
There also exists an option to set the includes destination via <code class="highlighter-rouge">INCLUDES DESTINATION</code>.
However, the includes destination has already been set via <code class="highlighter-rouge">target_include_directories</code> and thus can be omitted <sup id="fnref:HeaderOnly:1" role="doc-noteref"><a href="#fn:HeaderOnly" class="footnote" rel="footnote">5</a></sup>.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">install</span><span class="p">(</span>TARGETS <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib example_app
  EXPORT <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Targets
  ARCHIVE DESTINATION <span class="si">${</span><span class="nv">CMAKE_INSTALL_LIBDIR</span><span class="si">}</span>
  LIBRARY DESTINATION <span class="si">${</span><span class="nv">CMAKE_INSTALL_LIBDIR</span><span class="si">}</span>
  RUNTIME DESTINATION <span class="si">${</span><span class="nv">CMAKE_INSTALL_BINDIR</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<p>The header files require a separate installation command to copy them to a system directory.
You can either use <code class="highlighter-rouge">install(FILES)</code> to install a list of files or <code class="highlighter-rouge">install(DIRECTORY)</code> to install a whole directory.
Since all header files of the example package are stored in the <em>include/plain_cmake</em> directory, we use the latter.
Again, we use a <code class="highlighter-rouge">GNUInstallDirs</code> variable for the include destination.
Please note the ‚Äò/‚Äô after the ‚Äòinclude‚Äô.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">install</span><span class="p">(</span>DIRECTORY include/
  DESTINATION <span class="si">${</span><span class="nv">CMAKE_INSTALL_INCLUDEDIR</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="export-targets">Export Targets</h2>
<p>In the last section we associated the install targets with <code class="highlighter-rouge">plain_cmakeTargets</code>.
Now, we can use this association to generate the <em>plain_cmakeTargets.cmake</em> which will allow other projects to import our targets.
The <code class="highlighter-rouge">NAMESPACE</code> is be prepended to the target names, so we can link to this library via <code class="highlighter-rouge">plain_cmake::plain_cmake_lib</code>.
If you do not want to specify and associate an installation target, you could alternatively use <code class="highlighter-rouge">export(TARGETS)</code> to manually specify and export the targets for the build tree.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export</span><span class="p">(</span>EXPORT <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Targets
  FILE <span class="si">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Targets.cmake
  NAMESPACE <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>::<span class="p">)</span>
</code></pre></div></div>

<p>The export command makes the targets available in the build tree only <sup id="fnref:InstallExportCmake" role="doc-noteref"><a href="#fn:InstallExportCmake" class="footnote" rel="footnote">7</a></sup>.
To make the targets available for projects which are not part of the build tree, we also have to install them:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">install</span><span class="p">(</span>EXPORT <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Targets
  FILE <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Targets.cmake
  NAMESPACE <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>::
  DESTINATION <span class="si">${</span><span class="nv">ConfigPackageLocation</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="package-configuration-generation">Package Configuration Generation</h2>
<p>This section describes the steps required to enable the <code class="highlighter-rouge">find_package</code> mechanism.
For our plain_cmake project two files are required to turn it into a CMake package:</p>
<ul>
  <li><em>plain_cmakeConfigVersion.cmake</em></li>
  <li><em>plain_cmakeConfig.cmake</em></li>
</ul>

<p>We can use the <code class="highlighter-rouge">CMakePackageConfigHelpers</code> for the generation of both files <sup id="fnref:ConfigHelpers" role="doc-noteref"><a href="#fn:ConfigHelpers" class="footnote" rel="footnote">8</a></sup>.
The <em>plain_cmakeConfigVersion.cmake</em> can easily be generated by specifying the version number of the package and a compatibility setting:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">write_basic_package_version_file</span><span class="p">(</span>
  <span class="si">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>ConfigVersion.cmake
  VERSION <span class="si">${</span><span class="nv">PLAIN_CMAKE_VERSION</span><span class="si">}</span>
  COMPATIBILITY SameMajorVersion<span class="p">)</span>
</code></pre></div></div>

<p>Generating the <em>plain_cmakeConfig.cmake</em> involves a bit more work.
But, we can use the <code class="highlighter-rouge">configure_package_config_file</code> helper to simplify the process.
This helper function requires:</p>
<ul>
  <li>The <em>plain_cmakeConfig.cmake.in</em> makes the targets and dependencies available to the importing project.
This file will be explained in the next section.</li>
  <li>An output filename, which expands to <em>${CMAKE_CURRENT_BINARY_DIR}/plain_cmakeConfig.cmake</em>.</li>
  <li>The path where the <em>plain_cmakeConfig.cmake</em> will be installed, which is the same as the installation path of <em>plain_cmakeTargets.cmake</em>.</li>
  <li>The <code class="highlighter-rouge">PATHS_VARS variable1 variable2 ...</code> can be used to pass different installation locations to the <em>plain_cmakeConfig.cmake.in</em>.
Our example package only requires one variable <code class="highlighter-rouge">INCLUDE_INSTALL_DIR</code> for the location of the headers.</li>
</ul>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span><span class="p">(</span>INCLUDE_INSTALL_DIR <span class="si">${</span><span class="nv">CMAKE_INSTALL_INCLUDEDIR</span><span class="si">}</span><span class="p">)</span>
<span class="nf">configure_package_config_file</span><span class="p">(</span>
  <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Config.cmake.in
  <span class="si">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Config.cmake
  INSTALL_DESTINATION <span class="si">${</span><span class="nv">ConfigPackageLocation</span><span class="si">}</span>
  PATH_VARS INCLUDE_INSTALL_DIR<span class="p">)</span>
</code></pre></div></div>

<p>After generating both, the <em>ConfigVersion.cmake</em> and the <em>Config.cmake</em> files, they can be installed to a system directory.
We use the same installation command that we used for the installation of the header files.
It is important that the installation <code class="highlighter-rouge">DESTINATION</code> matches the one specified in <code class="highlighter-rouge">configure_package_config_file</code>.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">install</span><span class="p">(</span>FILES 
  <span class="si">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Config.cmake
  <span class="si">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>ConfigVersion.cmake
  DESTINATION <span class="si">${</span><span class="nv">ConfigPackageLocation</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="configcmakein">Config.cmake.in</h2>
<p>The first line will be automatically expanded by the config helpers to make the file relocatable.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@PACKAGE_INIT@
</code></pre></div></div>

<p>Next, we make the targets which we defined earlier available to the consumer projects:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">include</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_CURRENT_LIST_DIR</span><span class="si">}</span>/plain_cmakeTargets.cmake<span class="p">)</span>
</code></pre></div></div>

<p>If we want to use our library in a <strong>catkin package</strong> we are required to set the variables <code class="highlighter-rouge">plain_cmake_INCLUDE_DIRS</code> and <code class="highlighter-rouge">plain_cmake_LIBRARIES</code>.
Otherwise <code class="highlighter-rouge">catkin_package()</code> would result in the following warning:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catkin_package<span class="o">()</span> DEPENDS on <span class="s1">'plain_cmake'</span> but neither <span class="s1">'plain_cmake_INCLUDE_DIRS'</span> nor <span class="s1">'plain_cmake_LIBRARIES'</span> is defined.
</code></pre></div></div>

<p>To make our package relocatable, we use the <code class="highlighter-rouge">@PACKAGE_&lt;variable&gt;@</code> macro for the path of <code class="highlighter-rouge">plain_cmake_INCLUDE_DIRS</code>.
This macro expands the path variables from <code class="highlighter-rouge">PATH_VARS</code> we passed to <code class="highlighter-rouge">configure_package_config_file</code>.
Remember, we set the <code class="highlighter-rouge">INCLUDE_INSTALL_DIR</code> variable to <code class="highlighter-rouge">${CMAKE_INSTALL_INCLUDEDIR}</code>.
For example, when building the plain_cmake library in a catkin workspace, the macro <code class="highlighter-rouge">@PACKAGE_INCLUDE_INSTALL_DIR@</code> is the expanded <code class="highlighter-rouge">path/to/catkin_ws/devel/include</code>.</p>

<p>The <code class="highlighter-rouge">set_and_check</code> helper checks whether the path we set actually exists.
Moreover, we populate the <code class="highlighter-rouge">plain_cmake_LIBRARIES</code> with our library target - notice the namespace.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">set_and_check</span><span class="p">(</span>plain_cmake_INCLUDE_DIRS <span class="s2">"@PACKAGE_INCLUDE_INSTALL_DIR@"</span><span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>plain_cmake_LIBRARIES plain_cmake::plain_cmake_lib<span class="p">)</span>
</code></pre></div></div>

<p>Theoretically, we could use <code class="highlighter-rouge">find_package</code> and <code class="highlighter-rouge">target_link_libraries</code> to compile against our library now.
However, this would result in an error that the target <code class="highlighter-rouge">Eigen3::Eigen</code> was not be found.
Forwarding the dependencies is easily accomplished by using the find dependency macro.
Simply insert the same package requirements as in <code class="highlighter-rouge">find_package</code> from the beginning of your <em>CMakeLists.txt</em>.
The difference to <code class="highlighter-rouge">find_package</code> is that this macro will return with an error message from the <em>Config.cmake</em> iif the package cannot be found.</p>

<p>Please note that there seems to be an issue with the expansion of the <code class="highlighter-rouge">@PACKAGE_&lt;...&gt;@</code> macros when using <code class="highlighter-rouge">find_dependency</code> before it.
When finding Eigen3 before setting the <code class="highlighter-rouge">plain_cmake_INCLUDE_DIRS</code>, the path would be expanded to the Eigen3 include directory instead of the plain_cmake‚Äôs one.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">include</span><span class="p">(</span>CMakeFindDependencyMacro<span class="p">)</span>
<span class="nf">find_dependency</span><span class="p">(</span>Eigen3 3.3 REQUIRED NO_MODULE<span class="p">)</span>
</code></pre></div></div>

<p>Finally it is recommended to call the following line to confirm that all required components have been found:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">check_required_components</span><span class="p">(</span>plain_cmake<span class="p">)</span>
</code></pre></div></div>

<h1 id="usage">Usage</h1>
<p>Now that we have completed our plain CMake package, it is time to use it in another project.
We implemented the package so that it can be used in the build tree of a catkin workspace or from a system installation.</p>

<h2 id="catkin-workspace">Catkin Workspace</h2>
<p>Using the <code class="highlighter-rouge">plain_cmake</code> package is pretty straight forward, almost as using any other catkin package.
Catkin uses the <em>package.xml</em> to determine the build order <sup id="fnref:REP140:1" role="doc-noteref"><a href="#fn:REP140" class="footnote" rel="footnote">2</a></sup>.
Thus, we add the following line to the <em>package.xml</em> of the consumer package:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;depend&gt;</span>plain_cmake<span class="nt">&lt;/depend&gt;</span>
</code></pre></div></div>

<p>In the <em>CMakeLists.txt</em> of the catkin package we can use the <code class="highlighter-rouge">find_package</code> mechanism to use our plain_cmake package.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">find_package</span><span class="p">(</span>plain_cmake REQUIRED<span class="p">)</span> 
</code></pre></div></div>

<p>Catkin uses the <code class="highlighter-rouge">catkin_package</code> macro to generate the package configuration which we generated via <code class="highlighter-rouge">configure_package_config_file</code> and <code class="highlighter-rouge">write_basic_package_version_file</code>.
To forward our package further down the dependency tree, we have to add it as a non-catkin dependency <sup id="fnref:RosCmake" role="doc-noteref"><a href="#fn:RosCmake" class="footnote" rel="footnote">9</a></sup>:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">catkin_package</span><span class="p">(</span>
 CATKIN_DEPENDS roscpp std_msgs
 DEPENDS plain_cmake<span class="p">)</span>
</code></pre></div></div>

<p>After <code class="highlighter-rouge">catkin_package()</code>, the targets of the catkin package can be defined.
For example, we can add a ROS node executable that depends on the <code class="highlighter-rouge">plain_cmake_lib</code>.
If the package was found via <code class="highlighter-rouge">find_package()</code>, the library can be linked via <code class="highlighter-rouge">target_link_library()</code>.
Since we exported the target in the namespace <code class="highlighter-rouge">plain_cmake</code>, we have to link the node against <code class="highlighter-rouge">plain_cmake::plain_cmake_lib</code>.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_executable</span><span class="p">(</span>test_node src/test_node.cpp<span class="p">)</span>
<span class="nb">target_include_directories</span><span class="p">(</span>test_node 
  PRIVATE <span class="si">${</span><span class="nv">catkin_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>test_node
  PRIVATE <span class="si">${</span><span class="nv">catkin_LIBRARIES</span><span class="si">}</span> plain_cmake::plain_cmake_lib<span class="p">)</span>
</code></pre></div></div>

<p>Finally, we can compile the whole catkin workspace.
As the plain CMake package makes it a mixed workspace, we cannot use <code class="highlighter-rouge">catkin_make</code>.
Instead, <code class="highlighter-rouge">catkin_make_isolated</code><sup id="fnref:REP134" role="doc-noteref"><a href="#fn:REP134" class="footnote" rel="footnote">10</a></sup> or the catkin_tools have to be used.
An example can be found in <a href="https://github.com/Tuebel/ros_plain_cmake/tree/master/src/catkin_pkg">catkin_pkg</a>.</p>

<h2 id="cmake-system-installation">CMake System Installation</h2>
<p>Since the <code class="highlighter-rouge">plain_cmake</code> package‚Äôs only ROS bit is the <em>package.xml</em>, it can be installed and used like any other system dependency.
Navigate to the <em>plain_cmake</em> directory and create a <em>build</em> directory to keep the workspace clean.
Inside this directory we can call the typical sequence of commands to build and install a CMake package.
For development, I prefer using <code class="highlighter-rouge">checkinstall</code> instead of <code class="highlighter-rouge">make install</code> because it enables an easy cleanup via apackage manager like <code class="highlighter-rouge">dpkg</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>path/to/plain_cmake
<span class="nb">mkdir </span>build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
cmake ..
make
<span class="nb">sudo </span>checkinstall
</code></pre></div></div>

<p>After installing the package to the system, we can use it in another CMake project by finding it and linking against it just like in the catkin workspace example.
The only difference is, that we do not use the <code class="highlighter-rouge">catkin_package</code> macro.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">find_package</span><span class="p">(</span>plain_cmake<span class="p">)</span>
<span class="nb">add_executable</span><span class="p">(</span>app src/app.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>app plain_cmake::plain_cmake_lib<span class="p">)</span>
</code></pre></div></div>

<p>A full example can be found in <a href="https://github.com/Tuebel/ros_plain_cmake/tree/master/src/consumer_cmake">consumer_cmake</a>.
Note, that if you compile the whole repository with catkin, the consumer_cmake project is not compiled as it does not include a <em>package.xml</em>.</p>

<h1 id="conclusion">Conclusion</h1>
<p>We have implemented a plain CMake package that can be used in a catkin workspace and in a ROS-agnostic setting.
This portability is also useful, if you intend to transition to ROS2 in the near future, as colcon supports plain CMake packages, too.
If you have any questions or recommendations, feel free to comment or open a pull-request ü§ñ.</p>

<h2 id="references-and-useful-resources">References and Useful Resources</h2>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:CmakePackage" role="doc-endnote">
      <p>https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html¬†<a href="#fnref:CmakePackage" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:REP140" role="doc-endnote">
      <p>https://www.ros.org/reps/rep-0140.html¬†<a href="#fnref:REP140" class="reversefootnote" role="doc-backlink">&#8617;</a>¬†<a href="#fnref:REP140:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:UseCmakeEnabled" role="doc-endnote">
      <p>https://coderwall.com/p/qej45g/use-cmake-enabled-libraries-in-your-cmake-project-iii¬†<a href="#fnref:UseCmakeEnabled" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:DoCmakeRight" role="doc-endnote">
      <p>https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/¬†<a href="#fnref:DoCmakeRight" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:HeaderOnly" role="doc-endnote">
      <p>https://dominikberner.ch/cmake-interface-lib/¬†<a href="#fnref:HeaderOnly" class="reversefootnote" role="doc-backlink">&#8617;</a>¬†<a href="#fnref:HeaderOnly:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:ModernCmakeInstall" role="doc-endnote">
      <p>https://cliutils.gitlab.io/modern-cmake/chapters/install/installing.html¬†<a href="#fnref:ModernCmakeInstall" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:InstallExportCmake" role="doc-endnote">
      <p>https://medium.com/@kkunalsharma825/install-and-export-in-cmake-5c26d20ff715¬†<a href="#fnref:InstallExportCmake" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:ConfigHelpers" role="doc-endnote">
      <p>https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html¬†<a href="#fnref:ConfigHelpers" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:RosCmake" role="doc-endnote">
      <p>wiki.ros.org/catkin/CMakeLists.txt¬†<a href="#fnref:RosCmake" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:REP134" role="doc-endnote">
      <p>https://www.ros.org/reps/rep-0134.html¬†<a href="#fnref:REP134" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="ROS" /><category term="CMake" /><summary type="html"><![CDATA[Tutorial on creating a plain CMake package that can be used in a catkin workspace and as a system dependency without ROS.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://tuebel.github.io/blog/images/plain_cmake_preview.png" /><media:content medium="image" url="https://tuebel.github.io/blog/images/plain_cmake_preview.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>